# 数据结构总结归纳

## 1.什么是数据结构和算法

在现实世界中，不同的数据元素之间不是独立的，而是存在特定的关系，我们将这种关系称之为结构。

**数据结构：**是相互之间存在一种或多种特定关系的数据元素的集合。

数据：是描述客观事物的符号，是计算机可以操作的对象，是被计算机识别，并输入给计算机处理的符号集合。
数据元素：是组成数据的，有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。
数据项：一个数据元素可以由多个数据项组成，是数据不可分割的最小单位。
数据对象：是性质相同的数据元素的集合，是数据的子集，一般将数据对象简称为数据。

数据结构可以分为逻辑结构和物理结构：
逻辑结构是面向问题的，物理结构是面向计算机的，其基本目标就是将数据及其逻辑关系存储在计算机中。

**逻辑结构：**是指数据对象中的数据元素之间的相互关系。包括：
集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系
线性结构：数据元素之间是一对一的关系
树形结构：数据元素之间存在一种一对多的层次关系
图形结构：数据元素之间是多对多关系，没有层次。

**物理结构：**是指数据的逻辑结构在计算机中的存储形式。包括：
顺序存储形式：是把数据元素存放在地址连续的存储单元中，其数据间的逻辑关系和物理关系是一致的。
链式存储结构：是把数据元素存放在任意的存储单元中，这种存储单元可以是连续的，也可以是不连续的。

数据类型：是指一种性质相同的值的集合及定义在此集合上的一些操作。(类似于整型，浮点型)

抽象数据类型(Abstract Data Type,ADT):是指一个数学模型及定义在该模型上的一种操作。(类似于类和结构体)

**算法(algorithm):**算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

算法具有五个基本特性：输入，输出，有穷性，确定性和可行性
输入输出：算法有零个或多个输入，至少有一个输出
有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每个步骤都在可接受的时间内完成
确定性：算法的每一个步骤都具有确定的含义，不能出现二义性
可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成

算法设计的要求：
正确性：算法的正确性是指算法至少应该具有输入输出和加工处理无歧义性，能正确反应问题的需求，能够得到问题的正确答案
可读性：算法设计应该便于阅读，理解和交流
健壮性：当输入数据不合法时，算法也能够做出相关处理，而不是产生异常或莫名其妙的结果
时间效率高和存储量低

在分析一个算法的运行时间时，重要的是把基本操作的数量与输入规模关联起来，即基本操作的数量必须表示成输入规模的函数。

函数的渐近增长：给定两个函数f(n),g(n)，如果存在一个整数N，使得对于所有n>N,f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。于是我们可以得出一个结论，判断一个算法好不好，我们只通过少量的数据是不能做出准确的判断的，如果我们可以对比算法的关键执行次数函数的渐近增长性，基本就可以分析出:每个算法，随着n的变大，它会越来越优于另一算法，或者越来越差于另一算法。

**算法时间复杂度：**在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的复杂度，就是算法的时间度量，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的时间复杂度，简称时间复杂度。其中f(n)是问题规模n的每个函数。这种就大写O()来体现算法时间复杂度的记法，称为大0记法。
算法的时间复杂度只和算法的好坏与问题的输入规模有关，而和硬件，语言，编译的效率等无关。

**算法空间复杂度：**Sn=O(f(n))，n为问题的规模，f(n)为语句关于n所占存储空间的函数。

推导大O阶方法：

1. 用常数1取代运行时间中的所有加法系数
2. 在修改后的运行次数函数中，只保留最高阶项
3. 如果最高阶项存在且不是1，则去除与这个项相乘的系数。

常见的时间复杂度:

O(1) < O(logn) < O(n) < O(nlogn) < O(n^2^) < O(n^3^) < O(2^n^) < O(n!) < O(n^n^)

## 2.线性表

**线性表(List)：**零个或多个相同类型的数据元素的有限序列。
首先它是一个序列，也就是说元素之间是有顺序的。若元素存在多个，则第一个元素无前驱，最后一个元素无后驱，其他每个元素都有且只有一个前驱和后驱。长度为0的线性表称为空表。
(线性表，栈，队列等都指的是逻辑结构)

**线性表顺序存储结构：**用一段地址连续的存储单元依次存储线性表中的数据元素。通常由数组来实现这种结构。
优缺点：无须为列表中元素之间的逻辑关系增加额外的存储空间，支持随机访问，读取复杂度为常数复杂度O(1)。但插入和删除操作需要移动大量的元素，复杂度为O(n)。且线性表的长度变化较大时，难以确定存储空间的容量，需要预分配空间，分大了浪费，分小了发生溢出，容易造成存储空间的碎片和浪费。

**线性表的链式存储结构：**用一组任意的存储单元存放线性表的元素。链式存储结构每个结点(Node)由一个结构体变量构成，每个结点存储信息的域叫做数据域，存储直接后继位置的指针的域称为指针域。
链表中第一个结点的存储位置叫做头指针。为了更加方便地对链表进行操作，会在链表的第一个结点前附设一个头结点，头结点的数据域可以不存储任何信息，指针域存放第一个结点的地址，头结点不是必要的。有了头结点，对链表第一个结点的插入和删除的操作就和其他结点统一了。若链表有头结点，则头指针指向头结点。头指针具有标识作用，所以常用头指针冠以链表的名字。无论链表是否为空，头指针都不为空，头指针是链表的必要元素。
优缺点：查找O(n),单链表在找出插入或删除位置的指针后再进行插入和删除时间为O(1)。不需要预分配空间，而是需要是才开辟，元素个数不受限制，不会造成空间的浪费。但不支持随机访问。

当线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除，宜采用链式结构。
当线性表中的元素个数变化较大或者根本不知道有多大时，最好采用链式结构，这样可以不用考虑存储空间大小问题；而如果事先知道线性表的大致长度，宜采用顺序存储结构。

```c++
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0;
typedef int Status;

单链表的存储结构：
    typedef struct Node
    {
        ElemType data;
        struct Node * next;
    }Node;
	typedef struct Node* Linklist;

单链表的读取：
    Status GetElem(LinkList L,int i, ElemType* e)  //L是头指针，指向头结点，为指向指针的指针
{
    LinkList p=L->next; //p指向第一个结点
    int j=1;
    while(p&&j<i)
    {
        p=p->netx;//使p指向第i个结点
        j++;
    }
    if(!p||j>i)
        return ERROR;   //第i个结点不存在
    *e=p->data;
    return OK;
}

单链表的插入：(在第i个结点前插入一个元素)
    Status ListInsert(LinkList *L,int i, ElemType e)  //L为指向头指针的指针变量
{
     LinkList p=*L; //p指向头结点
     int j=1;
      while(p&&j<i)   
    {
        p=p->netx;//使p指向第i-1个结点
        j++;
    }
    if(!p||j>i)
        return ERROR;
    LinkList s=(LinkList)malloc(sizeof(Node));
    s->data=e;
    s->next=p->next;
    p->netx=s;
    return OK;
}

单链表的删除：(删除第i个结点)
     Status ListDelete(LinkList *L,int i, ElemType *e)   //e用来返回删除的值
{
     LinkList p=*L; //p指向头结点
     int j=1;
      while(p->netx&&j<i)
    {
        p=p->netx;//使p指向第i-1个结点
        j++;
    }
    if(!(p->next)||j>i)  //注意是p->next不是p
        return ERROR;
    LinkList temp=p->next;
    p->next=p->netx->netx;
    *e=p->next->data;
    delete temp;
    return OK;
}

单链表的整表创建：
      void CreateListHead(LinkList *L,int n)  //头插法
{
     *L=(LinkList)malloc(sizeof(Node));
     (*L)->next=NUll;
     LinkList p;
    srand(time(0));//生成随机数种子
    for(int i=0;i<n;i++)
    {
        p=(LinkList)malloc(sizeof(Node));
        p->data=rand()%100+1;
        p->next=(*L)->next;
        (*L)->next=p; 
    }
}
 	void CreateListTail(LinkList *L,int n)  //尾插法
    {
        *L=(LinkList)malloc(sizeof(Node));
     	(*L)->next=NUll;
     	LinkList p,cur;
        cur=*L;
    	srand(time(0));
       for(int i=0;i<n;i++)
    {
        p=(LinkList)malloc(sizeof(Node));
        p->data=rand()%100+1;
        p->next=NULL;
        cur->next=p; 
    }
    }

单链表的整表删除:
Status ClearList(LinkList *L)
{
    LinkList prior,cur;
    cur=(*L)->netx;
    while(cur)
    {
        prior=cur->next;
        delete cur;
        cur=prior;
    }
    (*L->next)=NULL;
    return Ok;
}
```

**静态链表：**用数组来描述的链表叫做静态链表。又称游标实现法。是为了给没有指针的高级语言设计的一种实现单链表功能的方法。

**循环链表(circular linked list)：**将单链表的终端结点的指针端有空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表(circular linked list).循环链表可以任一个结点出发访问链表的所以结点。

**双向链表(double linked list)：**在单链表的每个结点中，再设置一个指向其前驱结点的指针域。可以双向访问，是用空间换时间。

## 3.栈和队列

**栈(stack)：**是限定仅在表尾进行插入和删除操作的线性表。允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)，不含任何数据元素的栈称为空栈。栈又称后进先出(Last IN First Out)线性表，简称LIFO结构。
将栈看成垂直的，栈的插入操作，叫做进栈，也称压栈，入栈，栈的删除操作，叫做出栈，也叫弹栈。
对于栈的顺序存储结构来说，如果是两个相同数据结构的栈，则可以用数组的两端做栈底的方法来让两个栈实现共享数据，最大化利用数组的空间。

**队列(queue):**是限定在一端进行插入，在另一端进行删除操作的线性表。允许插入的一端称为队尾，允许删除的一端称为队首。队列是一种先入先出(First In First Out)的线性表，简称FIFO。类似于窗口排队。左边为队首，右边为队尾。
对于队列的顺序存储结构来说，为了避免数组的插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以同时在数组中循环变。解决了移动数据的时间损耗，使得本来插入和删除是O(n)的时间复杂度变成了O(1)。

栈和队列都属于线性表，只不过是操作受到限制的线性表。

### 栈的实现

#### 栈的顺序存储结构的实现：

```c++
    结构定义：
    typedef struct
    {
        SElemType data[MAXSIZE];//开辟固定大小的数组，固定死了栈的大小
        int top;//栈顶元素的索引。栈实际上就是只能在一端进行插入删除的数组。
    }SqStack;
	进栈操作：
    Status Push(Sqstack *S,SElemType e)
    {
        if(S->top=MAXSIZE-1)  //栈已满
            return ERROR;
        S->top++;
        S->data[S->top]=e;//或连写为 S->data[++S->top]=e;
        return OK;
    }
	出栈操作：
    Status Pop(Sqstack *S,SElemType *e)
    {
        if(S->top==-1)   //栈为空
            return ERROR;
        *e=S->data[S->top];
        S->top--;//可简写为 *e=S->data[S->top--]；
        return OK;
    }
```

#### 栈的链式存储结构实现：

栈的链式存储结构简称为链栈。把栈顶放在单链表的头部，由于以及有了栈顶在头部了，单链表中常见的头结点也就失去了意义，故对于链栈不需要头结点。

```c++
	结构定义：
      typedef struct StackNode
    {
        SElemType data;
        struct StackNode *next;
    }StackNode,*LinkStackPtr;
	typedef strcut LinkStack
    {
        LinkStackPtr top;//栈顶指针
        int count; //当前栈的大小
    } LinkStack；
        
        进栈操作：
            Status Push(LinkStack *S,SElemType e)
    {
        LinkStackPtr s=(LinkStackPtr)malloc(sizeof(StackNode));
        s->data=e;
        s->netx=S->top;
        S->top=s;
        S->count++;
        return OK;
    }
        出栈操作：
            Status Pop(LinkStack *S,SElemType *e)
        {
			 LinkStackPtr temp;
            if(StackEmpty(*S))
                return ERROR;//为空栈
            *e=S->top->data;
            temp=S->top;
            S->top=S->top->next;
            free(p);
            S->count--;
            return OK;
        }
//进栈时需要考虑满的问题，出栈时需要考虑空的问题
```

### 队列的实现

#### 队列的顺序存储结构的实现：

利用固定数组容易造成假溢出，浪费存储空间。以使用循环队列解决该问题，所谓循环队列，就是头尾相连的队列，数组后面满了再从头开始。

```c++
	结构定义：
    typedef struct
    {
        Elemtype data[MAXSIZE];
        int front;//队首
        int rear;//队尾
    }SqQueue；
    循环队列的初始化：
        Status InitQueue(SqQueue *Q)
    {
        Q->fronr=0;
        Q->rear=0;//rear指向队列队尾元素的后一个位置。当数组满时，数组中还有一个空闲单元
        return OK;
    }
	循环队列求队列长度：
        int QueueLength(SqQueue Q)
    {
        return (Q.rear-Q.front+MAXSIZE)%MAXSIZE；
    }
	入队操作：
        Status EnQueue(SqQueue *Q, Elemtype e)
    {
        if((Q.rear+1)%MAXSIZE==Q.front)//队列已满
          return ERROR; 
        Q->data[Q->rear]=e;
        Q->rear=(Q->rear+1)%MAXSIZE;//若rear本是最后一位则转到数组头部
        return OK;
    }
	出队操作：
         Status DeQueue(SqQueue *Q, Elemtype *e)
    {
        if(Q.rear==Q.front)
            return ERROR;//队列为空
        *e=Q->data[Q->front];
        Q->front=(Q->front+1)%MAXSIZE;
        return OK;
    }
```

#### 队列的链式存储结构的实现：

```c++
	结构定义：
      typedef struct QNode
    {
        ElemType data;
        struct QNode *next;
    }QueueNode,*LinkQueuePtr;
	typedef strcut LinkQueue
    {
        LinkQueuePtr front,rear;//front指向头结点，rear指向队尾
    }LinkQueue;
	
	入队操作：
        Status EnQueue(LinkQueue *Q, ElemType e)
    {
        LinkQueuePtr s=(LinkStackPtr)malloc(sizeof(StackNode));
        if(!s)
            exit(OVERFLOW);//存储空间分配失败
        s->data=e;
        s->next=NULL;
        Q->rear->next=s;
        Q->rear=s;
        return OK;
    }
	出队操作：
          Status DeQueue(LinkQueue *Q, ElemType *e)
    {
        ListQueueptr temp;
        if(Q->rear==Q->front)
            return ERROR;//队列为空
        temp=Q->front->next;//默认队列包含头结点。
        *e=temp->data;
        Q->front->next=temp->next;
        if(temp==Q->rear)//如果队列中除了头结点只有一个结点，则使rear也指向头结点，否则不需要动rear。
            Q->rear=Q->front;
        free(temp);
        return OK;
    }
```

## 4.串

**串(string):**是由零个或多个字符组成的有限序列，又名字符串。

一般记为"a~1~a~2~a~3~....a~n~"，串中的字符数目n称为串的长度，零个字符的串称为空串(null string)。

所谓序列，是指串的相邻字符之间具有前驱和后继的关系。

串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含字串的串称为主串。

与线性表相比，线性表更关注单个元素的操作，比如查找一个元素，插入或删除一个元素。而串中更多的是查找子串位置，得到指定位置的子串，替换子串等操作。

串可以用顺序存储结构也可以用链式存储结构，但总的来说，顺序存储结构性能较好。

**ASCII编码和Unicode编码：**计算机中常用的字符是使用标准的ASCII编码，由7位二进制数表示一个字符，总共可以表示128个字符，后来又扩展到由8位二进制数表示一个字符，共可以表示256个字符。但这远远不够表示世界上的所以字符，因此有了Unicode编码，使用16位二进制数表示一个字符，总共可以表示2^16^个字符，约6.5万个，足够表示世界上所有的字符。为了和ASCII码兼容，Unicode的前256个字符与ASCII码相同。

子串的定位操作通常称为串的模式匹配，是串中最重要的操作之一。

#### 串的朴素模式匹配算法

```c++
int Index(string S, string T, int pos)
{
	int slen = S.size();
	int tlen = T.size();
	int i = pos;//从pos开始搜索
	int j = 0;
	while (i<slen&& j<tlen)   //不能写成i<slen-tlen+1
	{
		if (S[i] == T[j])
		{
			++i;
			++j;
		}
		else
		{
			i = i - j + 1;//注意这里，i返回到上次匹配首位的下一位。首元素放的是字符串的长度，则应写为i-j+2
            if (i == slen - tlen + 1)
				break;  
			j = 0;
		}
		if (j == tlen)
			return i - tlen;
	} 
	return 0;
}
```

#### KMP模式匹配算法

```c++
#include<iostream>
#include<string>
using namespace std;
void get_next(string T, int *next)

{
	int i = 0;
	int j = -1;
	next[0] = -1;
	while (i<T.size() - 1)
	{
		if (j == -1 || T[i] == T[j])
		{
			++i;
			++j;
			next[i] = j;
		}
		else
			j = next[j];
	}
}
void get_nextval(string T, int *nextval)//改进next

{
	int i = 0;
	int j = -1;
	nextval[0] = -1;
	while (i<T.size() - 1)
	{
		if (j == -1 || T[i] == T[j])
		{
			++i;
			++j;
			if (T[i] != T[j])
			{
				nextval[i] = j;
			}
			else
				nextval[i] = nextval[j];
		}
		else
			j = nextval[j];
	}
}
int Index_KMP(string S, string T, int pos)
{
	int slen = S.size();
	int tlen = T.size();
	int i = pos;//从pos开始搜索
	int j = 0;
	//int next[255];
	int nextval[255];
	//get_next(T, next);
	get_nextval(T, nextval);
	while (i<slen&& j<tlen)
	{
		if (j == -1 || S[i] == T[j])//不要写成S[i] == T[j]||j== -1 
		{
			++i;
			++j;
		}
		else
		{
			if (i == slen - tlen + 1)
				break;
			//j = next[i];
			j = nextval[j];
		}
		if (j == tlen)
			return i - tlen;
	}
	return 0;
}
int main()
{
	string s, t;
	cin >> s >> t;
	cout << s << endl;
	cout << t << endl;
	/*int nextval[255];
	get_nextval(t, nextval);
	for (int i = 0; i < 20; i++)
		cout << nextval[i] << " ";*/
	cout << Index_KMP(s, t, 0) << endl;
	return 0;
}
```

## 5.树

  **树(Tree)**是n个结点的有限集。n=0时称为空树。在任意一棵非空空树中：(1)有且仅有一个特定的称为**根(Root)**的结点；(2)当n>1时，其余结点可分为m个(m>0)互不相交的有限集T1,T2...Tm，其中每个集合本身又是一棵树，并且称为根的**子树(SubTree)**。


树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为结点的**度(Degree)**。度为0的结点称为**叶子节点(Leef)**，或终端结点，简称叶子。度不为0的结点称为非终端结点或分支结点，除根节点外，分支结点也称内部节点。树的度是树内各节点的度的最大值。

结点的子树的根称为该节点的**孩子(child)**，相应的，该节点称为孩子的**双亲(parent)**。同一个双亲的孩子之间互称**兄弟(sibling)**。结点的祖先是从根到该节点所经分支上的所有结点，相反，以某结点为根的子树中的任一结点都称为该结点的子孙。

树是有层次的，子树一定是互不相交的。结点的**层次(level)**从根开始，根为第一层，根的孩子为第二层。双亲在同一层的结点互称**堂兄弟**。树中结点的最大层次称为树的**深度(Depth)或高度**。

如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。

**森林(Forest)**是m(m>=0)棵互不相交的树的集合。

#### 树的存储结构

##### 双亲表示法

以一组连续的空间存储树的结点，同时在每个节点中，附设一个指示器指向其双亲结点在数组中的位置。

```c++
#define MAX_TREE_SIZE 100
typedef int TELemType;
typedef struct PTNode
{
    TELemType data;
    int parent;
}PTNode;
typedef struct
{
    PTNode nodes[ MAX_TREE_SIZE];
    int r,n;//根的位置和树的节点数
} PTree;
```

这种存储结构便于找到结点的双亲。根据需求，还可以在结点中添加指向第一个孩子和右兄弟等位置的指针，比较灵活。

多重链表法：每个节点有多个指针域，其中每个指针指向一棵子树的根节点。

##### 孩子表示法

把每个结点的孩子排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用线性存储结构，存放进一个一位数组中。这种方式把孩子用单链表串了起来，便于找到结点的所有孩子。

```c++
typedef struct CTNode  //孩子链表
{
    int child;//孩子的序号(这里的序号指的是对整个树做层序遍历的编号，从0开始)，也即是每个结点在表头数组中的下标
    struct CTNode *next;
}*ChildPtr;
typedef struct  //表头结构
{
    TELemType data;
    ChildPtr firstchild;//指向该结点的孩子链表的头指针
    //int parent;  //双亲孩子表示法
}CTBox；
    typedef struct  //树结构
    {
        CTBox nodes[ MAX_TREE_SIZE];
        int r,n;//根的位置和节点数
    }CTRee;
```

这种方式便于找到孩子，但是不知道某个结点的双亲，可以为每个表头结点增加一个指向双亲的指针域，这称为双亲孩子表示法。

##### 孩子兄弟表示法

任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和右兄弟。称为孩子兄弟表示法。

```c++
typedef struct CSNode
{
     TELemType data;
    struct CSNode *firstchild,*rightsib;
}CSNode,*CSTree;
```

这种表示法将一棵复杂的树变成了一棵二叉树。

#### 二叉树

**二叉树(Binary Tree)**是n个(n>=0)个结点的有限集合，该集合或者为空集(称为空二叉树)，或者由一个根节点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树构成。
二叉树的左子树和右子树是有顺序的，次序不能颠倒。即使某个结点只有一棵子树，也要区分它是左子树还是右子树。

斜二叉树：所有的结点都只有左子树或右子树，每一层只有一个结点，结点的个数和二叉树的深度相同。线性表其实可以理解为一个斜二叉树。

满二叉树：所有的分支结点都存在左子树和右子树，并且所有叶子都在同一层。

完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号为i(1<=i<=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中的位置完全相同，则称为完全二叉树。

##### 二叉树的性质

1. 在二叉树的第i层上至多有2^i-1^个结点.
2. 深度为k的二叉树至多有2^k^-1个结点.
3. 对任意一棵二叉树T，如果其终端节点数为n~0~，度为2的节点数为n~2~，则有n~0~=n~2~+1.
4. 具有n个结点的完全二叉树的深度为[logn]+1.([x]表示不大于x的最大整数，即向下取整)
5. 如果对一棵有n个结点的完全二叉树的结点按层序编号(从1开始)，对任一结点i(1<=i<=n)有：
   1. 如果i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲是[i/2].(向下取整)
   2. 如果2i>n，结点i无左孩子(为叶子结点);否则其左孩子是结点2i.
   3. 如果2i+1>n，结点i无有=右孩子；否则其右孩子是结点2i+1.

##### 二叉树的存储结构

**顺序存储结构：**

二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，按照层序次序连续依次存储，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟的关系等。

对于完全二叉树，用顺序存储结构就可以表现出二叉树的结构。对于一般的二叉树，可以将其按完全二叉树编号，把不存在的结点设置为#，但这样会造成空间的浪费。故顺序存储结构一般只适用于完全二叉树。

**二叉链表：**

每个结点右数据域和两个分别指向左右孩子的指针构成。

```c++
typedef struct BiTNode
{
    TELemType data;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;
```

##### 遍历二叉树

二叉树的遍历(traversing binary tree)是指从根节点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次且仅被访问一次。

```c++
void PreOrderTraverse(BiTree T)  //前序遍历
{
    if(T==NULL)
        return;
    cout<<T->data;  //可以是对该节点的各种操作。
    PreOrderTraverse(T->lchild);
    PreOrderTraverse(T->rchild);
}

void InOrderTraverse(BiTree T)  //中序遍历
{
    if(T==NULL)
        return;
    InOrderTraverse(T->lchild);
    cout<<T->data;  //可以是对该节点的各种操作。
    InOrderTraverse(T->rchild);
}

void PostOrderTraverse(BiTree T)  //后序遍历
{
    if(T==NULL)
        return;
    PostOrderTraverse(T->lchild);
    PostOrderTraverse(T->rchild);
    cout<<T->data;  //可以是对该节点的各种操作。
}
```

已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。
已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。
已知前序遍历序列和后序遍历序列，不可以唯一确定一棵二叉树。

##### 二叉树的建立

```c++
按照前序遍历建立二叉树：
void CreateBiTree(BiTree *T)//指向指针的指针
{
    TELemType ch;
    cin>>ch;
    if(ch=="#")
        *T=NULL;
    else
    {
        *T=new BiTNode;
        if(!*T)
            exit(OVERFLOW)//堆溢出
        (*T)->data=ch;
        CreateBiTree(&(*T)->lchild);
        CreateBiTree(&(*T)->rchild);
    }
}
```

##### 线索二叉树

二叉链表的很多结点的指针域为空，可以将这些结点空的指针域利用起来，指向前驱或后继。这种指向前驱或后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树(Threaded Binary Tree)。

如果所用的二叉树需要经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储方式就是非常不错的选择。

#### 树、森林与二叉树的转换

树、森林与二叉树之间可以按照一定的方法相互转换。

树、森林的先根遍历与相应二叉树的前序遍历相同，后根遍历与相应二叉树的中序遍历相同。

#### 赫夫曼编码

压缩是把文本重新编码，以减少不必要的空间。赫夫曼(Huffman)编码是最基本的压缩编码方法。

对于带权的结点，结点的带权路径长度是从该节点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有的叶子结点的带权路径长度之和。假设有n个权值{w~1~,w~2~...w~n~}，构造一棵有n个叶子结点的二叉树，每个叶子结点带权w~k~，每个叶子结点的路径长度为l~k~，则其中带权路径长度WPL最小的二叉树称作**赫夫曼树**，也叫做最优二叉树。

**赫夫曼编码：**一般地，设需要编码的字符集为{d1,d2...dn}，各个字符在电文中出现的次数或频率集合为{w1,w2...wn}，以d1,d2...dn作为叶子节点，以w1,w2....wn作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表0，右分支代表1，则从根节点到叶子结点所经路径分支组成的0和1的序列便是该节点对应字符的赫夫曼编码。

构造赫夫曼树的赫夫曼算法：

1. 根据给定的n个权值{w1,w2...wn}构成n棵二叉树的集合F={T1,T2....Tn}，其中每棵二叉树Ti中只有一个带权为wi的根节点，其左右子树为空。
2. 在F中选取两棵根节点的权值最小的树作为左右子树构造一棵新的二叉树，且新的二叉树的根节点的权值为其左右子树的根节点的权值之和。
3. 在F中删除这两棵树，同时将新得到的二叉树加入F中。
4. 重复2和3步骤，直至F中只含一棵树为止。这棵树便是赫夫曼树。

## 6.图

## 7.查找

### 查找概论

**查找(Search)**是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素(或记录)。

查找表(search table)是由同一类型的数据元素(或记录)构成的集合，**关键字(key)**是数据元素中某个数据项的值，又称为键值，用它可以标识一个数据元素。可以标识一个记录的某个数据项(字段)称之为**关键码**，是关键字的抽象。若关键字可以唯一地标识一个记录，称为**主关键字(primary key)**，主关键字所在的数据项称为主主关键码。对于哪些可以标识多个数据元素的关键字，称为次关键字(secondary key)。

查找表按操作方式分为两类：静态查找表和动态查找表

**静态查找表(static search table)：**只作查找操作的查找表。

**动态查找表(dynamic search table)：**在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。

为了提高查找效率，我们需要专门为查找操作设置数据结构，这种面向查找操作的数据结构称为查找结构。逻辑上说，查找所基于的数据结构是集合，集合中的元素之间没有本质关系，可是想要获得较高的查找效率，就不能不改变数据元素之间的关系，在存储时将查找集合组织成表，树等结构。

对于静态查找表来说，可以用线性表结构来组织数据，可以使用顺序表进行顺序查找，还可以对主关键字进行排序再使用折半查找等进行更高效的查找。

对于动态查找表来说，可以用二叉排序树来组织数据。

### 顺序表查找

```c++
int Sequential_Search(int *a,int n, key)
{
    for(int i=0;i<n;i++)
    {
        if(a[i]==key)
            return i;
    }
    return -1;//查找不成功返回-1
}
int Sequential_Search2(int *a,int n,int key)
{
    a[n]=key;//在查找的尽头放置哨兵，免去了在查找过程中每一次比较后都需要判断查找位置是否越界的麻烦。
    int i=0;
    while(a[i]!=key)
        i++;
    if(i==n)
        return -1;//查找不成功返回-1
    return i;
}
```

### 有序表查找

数据元素按主关键字的大小顺序采用顺序存储结构存储在内存中。有折半查找(二分查找)，插值查找和斐波那契查找。

若一次排序后查找表不再变化，则使用静态有序查找表比较好。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用有序表查找。

```c++
折半查找(二分查找):
int Binary_Search(int *a,int n,int key)
{
    int low=0,high=n-1,mid;
    while(low<=high)
    {
        mid=(high+low)/2;//mid在中间向low取整
        if(key<a[mid])
            high=mid-1;
        else if(key>a[mid])
            low=mid+1;
        else
            return mid;//若查找表中没有要查找的数据元素，最后low=high还会再进入循环一次，导致最后low=high=mid
    }
    return -1;
}
最坏的情况是查找到关键字或查找失败的次数为[logn]+1(向下取整，如100个元素最多需要查询7次)。
    折半查找的时间复杂度为O(logn)，远远好于顺序查找的O(n)

插值查找(Interpolation Search)：
    将第7行改为mid=low+(high-low)*(key-a[low])/(a[high]-a[low])
    折半查找是每次mid游标都转到low和high中间，而插值查找的mid游标会自动根据low和high之间的元素分布转到更贴近key的位置。对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能要比折半查找好得多，但如果查找表的数据分布极不均匀，则用插值查找并不合适。
    
斐波那契查找：
    int Fibonacii_Search(int *a,int n,int key)
{
    int low,mid,high,i,k;
    low=0;
    high=n-1;
    k=0;
    while(n-1>F[k]-1)//F[k]为事先设置好的斐波那契数列
        k++;
    for(i=n;i<F[k]-1;i++)
        a[i]=a[n];
    while(low<=high)
    {
        mid=low+F[k-1]-1;
        if(key<a[mid])
        {
            high=mid-1;
            k=k-1:
        }
        else if(key>a[mid])
        {
            low=mid+1;
            k=k-2;
        }
        else
        {
            if(mid<=n-1)
                return mid;
            else
                return -1;
        }
    }
    return -1;
}
就平均性能而言，斐波那契查找优于折半查找，但是对于最坏情况低于折半查找。
    
    总的来说，三种有序表的查找本质上是分隔点的选择不同，各有优劣，实际开发中需要根据数据的具体特点来选择。
```

### 线性索引查找

索引是为了加快查找速度而设计的一种数据结构。索引就是把一个关键字与它对应的记录相关联的过程，一个索引由若干个索引项构成，每个索引项至少包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库以及磁盘文件的一种重要技术。
(是在查找表的基础上在建立一层查找表，因为下面的查找表可能是按时间等顺序存储的不便进行排序，只能使用顺序查找。)

索引按照结构分为线性索引，树形索引和多级索引。**线性索引**是将索引项集合组织成线性结构，也成为**索引表**，包括稠密索引，分块索引和倒排索引。

**稠密索引：**将数据集中的每个记录都对应一个索引项，并且索引项按照关键码有序排列。
稠密索引查找时可使用二分查找，查找速度快，但需要对每个数据元素都建立一个索引项，索引表的长度和查找表的长度相等，会占用较大的存储空间。

**分块索引：**对数据集进行分块，使其分块有序，但不要求块内有序，然后再对每一块建立一个索引项，从而减少索引项的个数。
每个索引项结构应包含最大关键码，块内记录个数和用于指向块首数据元素的指针。要保证下一个分块的最小关键字也要比上一个分块的最大关键字大。对索引表进行二分查找，再到相应的块内进行顺序查找。
分块索引在兼顾了对细分块不需要有序的情况下，大大增加了整体查找的速度，所以普遍被用于数据库查找等技术中。

**倒排索引(inverted index)：**倒排索引是一种最基础的搜索技术。索引项的结构由次关键码和记录号表构成，其中，记录号表存储具有相同次关键字的所有记录的记录号(可以是指向记录的指针或者该记录的主关键字)。
倒排索引源于实际应用中需要根据属性(或字段，次关键码)的值来查找记录，其优点是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录就可以知道记录的位置。但它的缺点是这个记录不定长，如对多篇文章所有单词建立倒排索引，那每个单词都对应相当多的文章编号，对索引表进行插入或删除等维护操作比较困难。

### 二叉排序树

二叉排序树是一种动态的查找表结构，可以使得插入和删除的效率不错，同时又可以比较高效地查找。

**二叉排序树(Binary Sort Tree)：**又称为二叉查找树，它或者是一棵空树，或者是具有下列性质的二叉树：

* 若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值
* 若它的右子树不空，则右子树上的所有结点值均大于它的根节点的值
* 它的左右子树也都是二叉排序树

二叉排序树的中序遍历是一个有序列表。

```c++
二叉排序树链表节点的结构定义：
typedef struct BiTNode
{
    int data;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;

查找：
Status SearchBST(BiTree T,int key,BiTree f,BiTree *p)
{                          //f指向T的双亲，初始值为NULL
    if(!T)
    {
        *p=f;     //无论查找到还是查找不到，p都指向指向查找路径的最后一个非空结点的指针，p是指向指针的指针
        return FALSE;
    }
    else if(key==T->data)
    {
        *p=T;
        return TRUE;
    }
    else if(key>T->data)
        return SearchBST(T->rchild,key,T,p);
    else
        return SearchBST(T->lchild,key,T,p);
}

插入操作：
Status InsertBST(BiTree *T,int key)
{
    BiTree p;//p为指针
    if(SearchBST(*T,key,NULL,&p))
        return FALSE;//树中已有相同结点则不再插入
    else
    {
        BiTree tmp=new BiTNode;
        tmp->data=key;
        tmp->lchild=tmp->rchild=NULL;//插入一定是在叶子结点下面进行插入
        if(!p)
            *T=tmp;//为空树
        else if(key<p->data)
            p->lchild=tmp;
        else 
            p->rchild=tmp;
        return TRUE;
    }
}

创建二叉排序树：
    int a[10]={2,1,4,12,41,2,2,14,1,2};
BiTree T=NULL;
for(int i=0;i<10;i++)
    InsertBST(&T,a[i]);

删除操作：
Status DeleteBST(BiTree *T,int key)   
{
    if(!*T)
        return FALSE;//对于删除操作，首先需要判断集合是否为空
    else
    {
        if(key==(*T)->data)
            return Delete(T);
        else if(k<(*T)->data)
            return DeleteBST(&(*T)->lchild,key); 
        else
            return DeleteBST(&(*T)->rchild,key); 
    }
}
Status Delete(BiTree *T)
{
    BiTree q,s;
    if((*T)->lchild==NULL) //若左子树为空
    {
        q=*T;(*T)=(*T)->rchild;delete q;
    }
    else if((*T)->rchild==NULL)  //若右子树为空
    {
        q=*T;(*T)=(*T)->lchild;delete q;
    }
    else     //若左右子树都不为空
    {
        q=*T;s=(*T)->lchild;
        while(s->rchild)  //左转然后向右到尽头，找到待删结点的前驱
        {
            q=s;s=s->rchild;//q指向待删结点的前驱的前驱
        }
        *T->data=s->data;  //用前驱的值取代待删结点的值，待删结点结构不变，只是需要重接前驱的子树。
        if(q==*T)   //要删除的结点的左孩子没有右孩子
            q->lchild=s->lchild;
        else
            q->rchild=s->lchild;
        delete s;
    }
    return TRUE;
}
```

二叉排序树的插入和删除比较方便，对于查找最多次数为树的深度。因此，二叉排序树的查找性能取决于二叉排序树的形状，深度越小查找性能越高。我们希望二叉排序树是比较平衡的，深度可以和完全二叉树相等，这样查找就等同于二分查找。

#### 平衡二叉树(AVL树)

平衡二叉树(Self-Balancing Binary Search Tree或Height-Balanced Binary Search Tree)是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多为1.

**结点的平衡因子BF(Balance Factor)**是结点的左子树的高度减去右子树的高度。

距离插入结点最近的，且以平衡因子的绝对值大于1的结点为根的子树，称为最小不平衡子树。

平衡二叉树构建的基本思想就是在构建二叉树的过程中，每当插入一个结点时，先检查是否因为插入节点而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点的链接关系，进行相应的旋转，使之成为新的平衡子树。总之，就是把隐患消灭在出现时。

当最小不平衡子树根节点的平衡因子BF是大于1时，就右旋，小于-1就左旋。插入结点后，最小不平衡子树的BF与它的子树的BF符号相反时，就需要进行双旋，先对其子结点进行一次旋转以使得符号相同，再对其进行一次反向旋转。

对于平衡二叉树，兼顾了查找和插入删除的效率，查找的时间复杂度为O(logn)，而插入删除的时间复杂度也为O(logn)。

```c++
平衡二叉树链表节点的结构定义：
typedef struct BiTNode
{
    int data;
    int bf;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;

右旋：
void R_Rotate(BiTree *T)   //BF>1,顺时针旋转
{
    BiTree L=(*T)->lchild;
    (*T)->lchild=L->rchild;
    L->rchild=*T;
    *T=L;//*T指向新的根节点
//将最小不平衡子树的根节点的左孩子变为根节点，并将左孩子的右孩子挂在根节点上。    
}

左旋：
void L_Rotate(BiTree *T)
{
    BiTree R=(*T)->rchild;
    (*T)->rchild=R->lchild;
    R->lchild=*T;
    *T=R;
}//将最小不平衡子树的根节点的右孩子变为根节点，并将右孩子的左孩子挂在根节点上。

左平衡旋转：
#define LH 1
#define EH 0
#define RH -1
void LeftBalance(BiTree *T)//T是需要调整的最小不平衡二叉树，BF都是插入后更新的值
{
    BiTree L,Lr;
    L=(*T)->lchild;
    switch(L->bf)
    {
        case LH:
            (*T)->bf=L->bf=EH;
            R_Rotate(T);//直接对根节点右旋
            break;
        case RH:
            Lr=L->rchild;
            switch(Lr->bf)
            {
                case LH:
                    (*T)->bf=RH;
                    L->bf=EH;
                    break;
                case EH:
                    (*T)->bf=L->bf=EH;//左孩子的右孩子没有孩子
                    break;
                case RH:
                    (*T)->bf=EH;
                    L->bf=LH;
                    break;
            }
            Lr->bf=EH;//单旋后新根结点的BF不一定等于0，但平衡旋转后新根结点的BF一定等于0
            L_Rotate(&L);
            R_Rotate(T);
    }
}

插入操作：
Status InsertAVL(BiTree *T,int e,Status *taller)
{                       //taller是用来指示当前的T是否长高
    if(!*T)   //递归的终止结点，新元素插入到叶子结点下面
    {
        *T=new BiTNode;
        (*T)->bf=EH;
        (*T)->data=e;
        (*T)->lchild=(*T)->rchild=NULL;
        *taller=TRUE;
    }
    else
    {
        if(e==(*T)->data)
        {
            *taller=FALSE;
            return FALSE;//树中已有相同的结点则不在插入。
        }
        if(e<(*T)->data)//继续在左子树中进行搜索
        {
            if(!InsertAVL(&(*T)->lchild,e,taller))
                return FALSE;//左子树中已存在新插入的结点
            if(*taller)//已插入到左子树并且左子树已长高需要进行旋转处理，否则无需处理
            {
                switch((*T)->bf)
                {
                    case LH://原来左子树比右子树高，需做左平衡旋转
                        LeftBalance(T);
                        *taller=FALSE;
                        break;
                    case EH://原本左右子树等高，现在左子树增高
                        (*T)->bf=LH;
                        *taller=TRUE;
                        break;
                    case RH://原本右子树等高，现在左右子树增高
                        (*T)->bf=EH;
                        *taller=FALSE;
                        break;
                }
            }
        }
        else   //继续在右子树中进行搜索
        {
            if(!InsertAVL(&(*T)->rchild,e,taller))
            return FALSE;//右子树中已存在新插入的结点
            if(*taller)//已插入到左子树并且左子树已长高需要进行旋转处理，否则无需处理
            {
                switch((*T)->bf)
                {
                    case LH://原来左子树比右子树高，现在左右子树等高
                         (*T)->bf=EH;
                        *taller=FALSE;
                        break;
                    case EH://原本左右子树等高，现在右子树增高
                        (*T)->bf=EH;
                        *taller=TRUE;
                        break;
                    case RH://原本右子树高，需做右平衡旋转
                         RightBalance(T);
                        *taller=FALSE;
                        break;
                }
            }
        }
    }
    return TRUE;
}
```

### 多路查找树(B树)



### 散列表(hash table)

散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)，这种对应关系f称为散列函数，也称为哈希函数。采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间称为散列函数或者哈希表(hash table)，关键字对应的存储位置称为散列地址。

散列技术即是一种存储方法也是一种查找方法。与线性表，图，二叉树等结构不同，这几种结构的数据元素之间都存在某种逻辑关系，在存储时会按照其逻辑结构进行存储，在查找时会和关键字进行反复比较。而散列技术的记录之间不存在什么逻辑关系，它只与关键字有关联，知道关键字可以直接一步到位查找到结果，而不需要与关键字之间进行反复比较。因此，散列主要是面向查找的存储结构，散列技术最适合的求解问题就是查找与给定值相等的记录，简化了比较过程，大大提高了查找效率。

但对于那种同样的关键字却对应很多记录的情况，不适合用散列技术。散列表也不适合范围查找，且表中记录的排序，最大值，最小值等也不能直接从表中计算出来。

两个关键字key1≠key2，但f(key1)=f(key2)，这种现象称为冲突(collision)，key1和key2称为这个散列函数的同义词(synonym)。

#### 散列函数的构造方法

设计一个简单，均匀，存储利用率高的散列函数是散列技术中的最关键的问题。

一个好的散列函数需要满足以下两个条件：

1. 计算简单：散列函数的计算时间不应该超过其他查找技术与关键字比较的时间。
2. 散列地址分布均匀：尽量让散列地址均匀地分布在存储空间中，这样可以保证存储空间的有效利用，并减少为处理冲突而耗费的时间。

##### 1.直接定址法

取关键字的某个线性函数值为散列地址：

> ​																			f(key)=a*key+b(a,b为常数)

这种散列函数的优点是简单，均匀，也不会产生冲突，但问题是这需要事先知道关键字的分布情况(否则无法确定a,b的值)，适合查找表较小且连续的情况。

##### 2.数字分析法

抽取关键字的一部分来计算散列函数的存储位置，抽取的这一部分应当可以代表整个关键字，具有较强的标识作用(如手机号的后四位)。
数字分析法通常适合处理事先知道关键字的分布，且关键字的位数比较大的情况和关键字的若干位分布较均匀的情况。

##### 3.平方取中法

关键字平方后取中间几位做散列地址。适合于事先不知道关键字的分布且位数又不是很大的情况。

##### 4.折叠法

将关键字从左到右分割成位数相等的几部分(最后一部分位数不够时可以再短些)，然后将这几部分叠加求和，并按散列表的表长，取后几位作为散列地址。
适合事先不知道关键字的分布且关键字位数较多的情况。

##### 5.除留余数法

此方法是最常用的构造散列函数的方法。

> ​                                                                           f(key)=key mod p(p<=m)

不仅可以堆关键字进行取模，还可在折叠，平法取中后再取模。
本方法的关键在于选择合适的p，p取得不好，可能产生很多同义词。根据前辈们的经验，若散列表表长为m，通常p为小于等于表长(最好接近m)的最小质数或者不包含小于20质因子的合数。

##### 6.随机数法

>  				                    f(key)=random(key)

随机数法适合关键字长度不等的情况。

**总之**，不论采取什么方法，总的目的都是为了提供一个散列函数，能够将关键字合理地映射到散列表的各位置。现实中，应该视不同的情况采用不同的散列函数，可以参考以下几个因素：1.计算散列地址的时间 2.关键字的长度 3.散列表的大小 4.关键的分布情况 5.查找记录的频率

#### 处理散列冲突的方法

##### 1.开放定址法

所谓开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表未被填满，空的散列地址总能找到，并将记录存入。

> ​        	                                             fi(key)=(f(key)+di) mod m      (m为散列表的长度)
>
> 线性探测法：di=1,2,3...m-1。           这种方法可能造成不是同义词却需要争夺同一个地址的情况，容易造成关键字都聚集在某一块区域，这种现象称为堆积。
>
> 二次探测法：di=1^2^,-1^2^,2^2^,-2^2^,....q^2^,-q^2^.(q<=m/2)。          增加平方是为了不让关键字聚集在某一块区域。
>
> 随机探测法：di=random()。              在查找时需要设置同样的随机数种子。 

##### 2.再散列函数法

>  				                       fi(key)=RHi(key) (i=1,2...k)

当发生冲突时就换一个散列函数计算

##### 3.链接地址法

将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。

链接地址法对于可能造成很多冲突的散列函数来说，提供了绝不会出现找不到地址的保障，保证所有记录都可以有地方存储。但查找时需要遍历单链表，削弱了散列表查找的优势。

##### 4.公共溢出区法

为所有冲突的关键字额外建立一个公共的溢出区来存放。在查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对，如果相同则查找成功，如果不等则到公共溢出区进行顺序查找。当相对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构的查找性能还是比较高的。

#### 散列表的实现

```c++
#define SUCCESS 1
#define UNSUCCESS 0
#define HASHSIZE 12
#define NULLKEY -32768
typedef struct
{
   int *elem;//数据元素存储基址，动态分配数组
   int count;//当前数据元素的个数
}HashTable;
int m=0;//散列表表长，全局变量

散列表的初始化：
    Status InitHashTable(HashTable *H)
{
    m=HASHSIZE;
    H->count=m;
    H->elem=(int*)malloc(m*sizeof(int));//指针->数组名还是一个指针，与数组名等价
    for(int i=0;i<m;i++)
        H->elem[i]=NULLKEY;//指针->数组名[下标]是数组的一个元素
    return OK；
}

散列函数：
    int Hash(int key)
{
    return key%m; //除留余数法
}

插入关键字进散列表：
    void InsertHash(HashTable *H,int key)
{
    int addr=Hash(key);
    while(H->elem[addr]！=NULLKEY)
        addr=(addr+1)%m;   //开放定址法的线性探测
    H->elem[addr]=key;
}

查找：
    Status SearchHash(HashTable H,int key,int *addr)
{
    *addr=Hash(key);    //addr是要返回的地址
    while(H.elem[*addr]!=key)
    {
        *addr=(*addr+1)%m;
        if(H.elem[*addr]==NULLKEY||*addr==Hash(k))
            return UNSUCCESS;
    }
    return SUCCESS;
}
```

如果没有冲突，散列查找是最快你的查找方法，时间复杂度为O(1)。但实际性能受冲突的影响，与散列函数是否均匀，处理冲突的方法及散列表的装填因子有关。
所谓的装填因子α=填入表中的记录个数/散列表的长度，α越大，产生冲突的可能性就越大。因此，为了降低装填因子，通常我们都是将散列表的空间设置的比查找集合大，这样虽然浪费了一定的空间，但换来的是查找效率的大大提升。

## 8.排序算法

​	
# 数据结构总结归纳

## 1.什么是数据结构和算法

在现实世界中，不同的数据元素之间不是独立的，而是存在特定的关系，我们将这种关系称之为结构。

**数据结构：**是相互之间存在一种或多种特定关系的数据元素的集合。

数据：是描述客观事物的符号，是计算机可以操作的对象，是被计算机识别，并输入给计算机处理的符号集合。
数据元素：是组成数据的，有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。
数据项：一个数据元素可以由多个数据项组成，是数据不可分割的最小单位。
数据对象：是性质相同的数据元素的集合，是数据的子集，一般将数据对象简称为数据。

数据结构可以分为逻辑结构和物理结构：
逻辑结构是面向问题的，物理结构是面向计算机的，其基本目标就是将数据及其逻辑关系存储在计算机中。

**逻辑结构：**是指数据对象中的数据元素之间的相互关系。包括：
集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系
线性结构：数据元素之间是一对一的关系
树形结构：数据元素之间存在一种一对多的层次关系
图形结构：数据元素之间是多对多关系，没有层次。

**物理结构：**是指数据的逻辑结构在计算机中的存储形式。包括：
顺序存储形式：是把数据元素存放在地址连续的存储单元中，其数据间的逻辑关系和物理关系是一致的。
链式存储结构：是把数据元素存放在任意的存储单元中，这种存储单元可以是连续的，也可以是不连续的。

数据类型：是指一种性质相同的值的集合及定义在此集合上的一些操作。(类似于整型，浮点型)

抽象数据类型(Abstract Data Type,ADT):是指一个数学模型及定义在该模型上的一种操作。(类似于类和结构体)

**算法(algorithm):**算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

算法具有五个基本特性：输入，输出，有穷性，确定性和可行性
输入输出：算法有零个或多个输入，至少有一个输出
有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每个步骤都在可接受的时间内完成
确定性：算法的每一个步骤都具有确定的含义，不能出现二义性
可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成

算法设计的要求：
正确性：算法的正确性是指算法至少应该具有输入输出和加工处理无歧义性，能正确反应问题的需求，能够得到问题的正确答案
可读性：算法设计应该便于阅读，理解和交流
健壮性：当输入数据不合法时，算法也能够做出相关处理，而不是产生异常或莫名其妙的结果
时间效率高和存储量低

在分析一个算法的运行时间时，重要的是把基本操作的数量与输入规模关联起来，即基本操作的数量必须表示成输入规模的函数。

函数的渐近增长：给定两个函数f(n),g(n)，如果存在一个整数N，使得对于所有n>N,f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。于是我们可以得出一个结论，判断一个算法好不好，我们只通过少量的数据是不能做出准确的判断的，如果我们可以对比算法的关键执行次数函数的渐近增长性，基本就可以分析出:每个算法，随着n的变大，它会越来越优于另一算法，或者越来越差于另一算法。

**算法时间复杂度：**在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的复杂度，就是算法的时间度量，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的时间复杂度，简称时间复杂度。其中f(n)是问题规模n的每个函数。这种就大写O()来体现算法时间复杂度的记法，称为大0记法。
算法的时间复杂度只和算法的好坏与问题的输入规模有关，而和硬件，语言，编译的效率等无关。

**算法空间复杂度：**Sn=O(f(n))，n为问题的规模，f(n)为语句关于n所占存储空间的函数。

推导大O阶方法：

1. 用常数1取代运行时间中的所有加法系数
2. 在修改后的运行次数函数中，只保留最高阶项
3. 如果最高阶项存在且不是1，则去除与这个项相乘的系数。

常见的时间复杂度:

O(1) < O(logn) < O(n) < O(nlogn) < O(n^2^) < O(n^3^) < O(2^n^) < O(n!) < O(n^n^)

## 2.线性表

**线性表(List)：**零个或多个相同类型的数据元素的有限序列。
首先它是一个序列，也就是说元素之间是有顺序的。若元素存在多个，则第一个元素无前驱，最后一个元素无后驱，其他每个元素都有且只有一个前驱和后驱。长度为0的线性表称为空表。
(线性表，栈，队列等都指的是逻辑结构)

**线性表顺序存储结构：**用一段地址连续的存储单元依次存储线性表中的数据元素。通常由数组来实现这种结构。
优缺点：无须为列表中元素之间的逻辑关系增加额外的存储空间，支持随机访问，读取复杂度为常数复杂度O(1)。但插入和删除操作需要移动大量的元素，复杂度为O(n)。且线性表的长度变化较大时，难以确定存储空间的容量，需要预分配空间，分大了浪费，分小了发生溢出，容易造成存储空间的碎片和浪费。

**线性表的链式存储结构：**用一组任意的存储单元存放线性表的元素。链式存储结构每个结点(Node)由一个结构体变量构成，每个结点存储信息的域叫做数据域，存储直接后继位置的指针的域称为指针域。
链表中第一个结点的存储位置叫做头指针。为了更加方便地对链表进行操作，会在链表的第一个结点前附设一个头结点，头结点的数据域可以不存储任何信息，指针域存放第一个结点的地址，头结点不是必要的。有了头结点，对链表第一个结点的插入和删除的操作就和其他结点统一了。若链表有头结点，则头指针指向头结点。头指针具有标识作用，所以常用头指针冠以链表的名字。无论链表是否为空，头指针都不为空，头指针是链表的必要元素。
优缺点：查找O(n),单链表在找出插入或删除位置的指针后再进行插入和删除时间为O(1)。不需要预分配空间，而是需要是才开辟，元素个数不受限制，不会造成空间的浪费。但不支持随机访问。

当线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除，宜采用链式结构。
当线性表中的元素个数变化较大或者根本不知道有多大时，最好采用链式结构，这样可以不用考虑存储空间大小问题；而如果事先知道线性表的大致长度，宜采用顺序存储结构。

```c++
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0;
typedef int Status;

单链表的存储结构：
    typedef struct Node
    {
        ElemType data;
        struct Node * next;
    }Node;
	typedef struct Node* Linklist;

单链表的读取：
    Status GetElem(LinkList L,int i, ElemType* e)  //L是头指针，指向头结点
{
    LinkList p=L->next; //p指向第一个结点
    int j=1;
    while(p&&j<i)
    {
        p=p->netx;//使p指向第i个结点
        j++;
    }
    if(!p||j>i)
        return ERROR;   //第i个结点不存在
    *e=p->data;
    return OK;
}

单链表的插入：(在第i个结点前插入一个元素)
    Status ListInsert(LinkList *L,int i, ElemType e)  //L为指向头指针的指针变量
{
     LinkList p=*L; //p指向头结点
     int j=1;
      while(p&&j<i)   
    {
        p=p->netx;//使p指向第i-1个结点
        j++;
    }
    if(!p||j>i)
        return ERROR;
    LinkList s=(LinkList)malloc(sizeof(Node));
    s->data=e;
    s->next=p->next;
    p->netx=s;
    return OK;
}

单链表的删除：(删除第i个结点)
     Status ListDelete(LinkList *L,int i, ElemType *e)   //e用来返回删除的值
{
     LinkList p=*L; //p指向头结点
     int j=1;
      while(p->netx&&j<i)
    {
        p=p->netx;//使p指向第i-1个结点
        j++;
    }
    if(!(p->next)||j>i)  //注意是p->next不是p
        return ERROR;
    LinkList temp=p->next;
    p->next=p->netx->netx;
    *e=p->next->data;
    delete temp;
    return OK;
}

单链表的整表创建：
      void CreateListHead(LinkList *L,int n)  //头插法
{
     *L=(LinkList)malloc(sizeof(Node));
     (*L)->next=NUll;
     LinkList p;
    srand(time(0));//生成随机数种子
    for(int i=0;i<n;i++)
    {
        p=(LinkList)malloc(sizeof(Node));
        p->data=rand()%100+1;
        p->next=(*L)->next;
        (*L)->next=p; 
    }
}
 	void CreateListTail(LinkList *L,int n)  //尾插法
    {
        *L=(LinkList)malloc(sizeof(Node));
     	(*L)->next=NUll;
     	LinkList p,cur;
        cur=*L;
    	srand(time(0));
       for(int i=0;i<n;i++)
    {
        p=(LinkList)malloc(sizeof(Node));
        p->data=rand()%100+1;
        p->next=NULL;
        cur->next=p; 
    }
    }

单链表的整表删除:
Status ClearList(LinkList *L)
{
    LinkList prior,cur;
    cur=(*L)->netx;
    while(cur)
    {
        prior=cur->next;
        delete cur;
        cur=prior;
    }
    (*L->next)=NULL;
    return Ok;
}
```

**静态链表：**用数组来描述的链表叫做静态链表。又称游标实现法。是为了给没有指针的高级语言设计的一种实现单链表功能的方法。

**循环链表(circular linked list)：**将单链表的终端结点的指针端有空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表(circular linked list).循环链表可以任一个结点出发访问链表的所以结点。

**双向链表(double linked list)：**在单链表的每个结点中，再设置一个指向其前驱结点的指针域。可以双向访问，是用空间换时间。

## 3.栈和队列

**栈(stack)：**是限定仅在表尾进行插入和删除操作的线性表。允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)，不含任何数据元素的栈称为空栈。栈又称后进先出(Last IN First Out)线性表，简称LIFO结构。
将栈看成垂直的，栈的插入操作，叫做进栈，也称压栈，入栈，栈的删除操作，叫做出栈，也叫弹栈。

**队列(queue):**是限定在队尾进行插入，在队首进行删除的线性表。即先入先出。

## 4.树

## 5.图

## 6.搜索算法

## 7.排序算法

​	
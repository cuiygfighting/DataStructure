# 数据结构总结归纳

## 1.什么是数据结构和算法

在现实世界中，不同的数据元素之间不是独立的，而是存在特定的关系，我们将这种关系称之为结构。

**数据结构：**是相互之间存在一种或多种特定关系的数据元素的集合。

数据：是描述客观事物的符号，是计算机可以操作的对象，是被计算机识别，并输入给计算机处理的符号集合。
数据元素：是组成数据的，有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。
数据项：一个数据元素可以由多个数据项组成，是数据不可分割的最小单位。
数据对象：是性质相同的数据元素的集合，是数据的子集，一般将数据对象简称为数据。

数据结构可以分为逻辑结构和物理结构：
逻辑结构是面向问题的，物理结构是面向计算机的，其基本目标就是将数据及其逻辑关系存储在计算机中。

**逻辑结构：**是指数据对象中的数据元素之间的相互关系。包括：
集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系
线性结构：数据元素之间是一对一的关系
树形结构：数据元素之间存在一种一对多的层次关系
图形结构：数据元素之间是多对多关系，没有层次。

**物理结构：**是指数据的逻辑结构在计算机中的存储形式。包括：
顺序存储形式：是把数据元素存放在地址连续的存储单元中，其数据间的逻辑关系和物理关系是一致的。
链式存储结构：是把数据元素存放在任意的存储单元中，这种存储单元可以是连续的，也可以是不连续的。

数据类型：是指一种性质相同的值的集合及定义在此集合上的一些操作。(类似于整型，浮点型)

抽象数据类型(Abstract Data Type,ADT):是指一个数学模型及定义在该模型上的一种操作。(类似于类和结构体)

**算法(algorithm):**算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

算法具有五个基本特性：输入，输出，有穷性，确定性和可行性
输入输出：算法有零个或多个输入，至少有一个输出
有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每个步骤都在可接受的时间内完成
确定性：算法的每一个步骤都具有确定的含义，不能出现二义性
可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成

算法设计的要求：
正确性：算法的正确性是指算法至少应该具有输入输出和加工处理无歧义性，能正确反应问题的需求，能够得到问题的正确答案
可读性：算法设计应该便于阅读，理解和交流
健壮性：当输入数据不合法时，算法也能够做出相关处理，而不是产生异常或莫名其妙的结果
时间效率高和存储量低

在分析一个算法的运行时间时，重要的是把基本操作的数量与输入规模关联起来，即基本操作的数量必须表示成输入规模的函数。

函数的渐近增长：给定两个函数f(n),g(n)，如果存在一个整数N，使得对于所有n>N,f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。于是我们可以得出一个结论，判断一个算法好不好，我们只通过少量的数据是不能做出准确的判断的，如果我们可以对比算法的关键执行次数函数的渐近增长性，基本就可以分析出:每个算法，随着n的变大，它会越来越优于另一算法，或者越来越差于另一算法。

**算法时间复杂度：**在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的复杂度，就是算法的时间度量，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的时间复杂度，简称时间复杂度。其中f(n)是问题规模n的每个函数。这种就大写O()来体现算法时间复杂度的记法，称为大0记法。
算法的时间复杂度只和算法的好坏与问题的输入规模有关，而和硬件，语言，编译的效率等无关。

**算法空间复杂度：**Sn=O(f(n))，n为问题的规模，f(n)为语句关于n所占存储空间的函数。

推导大O阶方法：

1. 用常数1取代运行时间中的所有加法系数
2. 在修改后的运行次数函数中，只保留最高阶项
3. 如果最高阶项存在且不是1，则去除与这个项相乘的系数。

常见的时间复杂度:

O(1) < O(logn) < O(n) < O(nlogn) < O(n^2^) < O(n^3^) < O(2^n^) < O(n!) < O(n^n^)

## 2.线性表

**线性表(List)：**零个或多个相同类型的数据元素的有限序列。
首先它是一个序列，也就是说元素之间是有顺序的。若元素存在多个，则第一个元素无前驱，最后一个元素无后驱，其他每个元素都有且只有一个前驱和后驱。长度为0的线性表称为空表。
(线性表，栈，队列等都指的是逻辑结构)

**线性表顺序存储结构：**用一段地址连续的存储单元依次存储线性表中的数据元素。通常由数组来实现这种结构。
优缺点：无须为列表中元素之间的逻辑关系增加额外的存储空间，支持随机访问，读取复杂度为常数复杂度O(1)。但插入和删除操作需要移动大量的元素，复杂度为O(n)。且线性表的长度变化较大时，难以确定存储空间的容量，需要预分配空间，分大了浪费，分小了发生溢出，容易造成存储空间的碎片和浪费。

**线性表的链式存储结构：**用一组任意的存储单元存放线性表的元素。链式存储结构每个结点(Node)由一个结构体变量构成，每个结点存储信息的域叫做数据域，存储直接后继位置的指针的域称为指针域。
链表中第一个结点的存储位置叫做头指针。为了更加方便地对链表进行操作，会在链表的第一个结点前附设一个头结点，头结点的数据域可以不存储任何信息，指针域存放第一个结点的地址，头结点不是必要的。有了头结点，对链表第一个结点的插入和删除的操作就和其他结点统一了。若链表有头结点，则头指针指向头结点。头指针具有标识作用，所以常用头指针冠以链表的名字。无论链表是否为空，头指针都不为空，头指针是链表的必要元素。
优缺点：查找O(n),单链表在找出插入或删除位置的指针后再进行插入和删除时间为O(1)。不需要预分配空间，而是需要是才开辟，元素个数不受限制，不会造成空间的浪费。但不支持随机访问。

当线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除，宜采用链式结构。
当线性表中的元素个数变化较大或者根本不知道有多大时，最好采用链式结构，这样可以不用考虑存储空间大小问题；而如果事先知道线性表的大致长度，宜采用顺序存储结构。

```c++
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0;
typedef int Status;

单链表的存储结构：
    typedef struct Node
    {
        ElemType data;
        struct Node * next;
    }Node;
	typedef struct Node* Linklist;

单链表的读取：
    Status GetElem(LinkList L,int i, ElemType* e)  //L是头指针，指向头结点，为指向指针的指针
{
    LinkList p=L->next; //p指向第一个结点
    int j=1;
    while(p&&j<i)
    {
        p=p->netx;//使p指向第i个结点
        j++;
    }
    if(!p||j>i)
        return ERROR;   //第i个结点不存在
    *e=p->data;
    return OK;
}

单链表的插入：(在第i个结点前插入一个元素)
    Status ListInsert(LinkList *L,int i, ElemType e)  //L为指向头指针的指针变量
{
     LinkList p=*L; //p指向头结点
     int j=1;
      while(p&&j<i)   
    {
        p=p->netx;//使p指向第i-1个结点
        j++;
    }
    if(!p||j>i)
        return ERROR;
    LinkList s=(LinkList)malloc(sizeof(Node));
    s->data=e;
    s->next=p->next;
    p->netx=s;
    return OK;
}

单链表的删除：(删除第i个结点)
     Status ListDelete(LinkList *L,int i, ElemType *e)   //e用来返回删除的值
{
     LinkList p=*L; //p指向头结点
     int j=1;
      while(p->netx&&j<i)
    {
        p=p->netx;//使p指向第i-1个结点
        j++;
    }
    if(!(p->next)||j>i)  //注意是p->next不是p
        return ERROR;
    LinkList temp=p->next;
    p->next=p->netx->netx;
    *e=p->next->data;
    delete temp;
    return OK;
}

单链表的整表创建：
      void CreateListHead(LinkList *L,int n)  //头插法
{
     *L=(LinkList)malloc(sizeof(Node));
     (*L)->next=NUll;
     LinkList p;
    srand(time(0));//生成随机数种子
    for(int i=0;i<n;i++)
    {
        p=(LinkList)malloc(sizeof(Node));
        p->data=rand()%100+1;
        p->next=(*L)->next;
        (*L)->next=p; 
    }
}
 	void CreateListTail(LinkList *L,int n)  //尾插法
    {
        *L=(LinkList)malloc(sizeof(Node));
     	(*L)->next=NUll;
     	LinkList p,cur;
        cur=*L;
    	srand(time(0));
       for(int i=0;i<n;i++)
    {
        p=(LinkList)malloc(sizeof(Node));
        p->data=rand()%100+1;
        p->next=NULL;
        cur->next=p; 
    }
    }

单链表的整表删除:
Status ClearList(LinkList *L)
{
    LinkList prior,cur;
    cur=(*L)->netx;
    while(cur)
    {
        prior=cur->next;
        delete cur;
        cur=prior;
    }
    (*L->next)=NULL;
    return Ok;
}
```

**静态链表：**用数组来描述的链表叫做静态链表。又称游标实现法。是为了给没有指针的高级语言设计的一种实现单链表功能的方法。

**循环链表(circular linked list)：**将单链表的终端结点的指针端有空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表(circular linked list).循环链表可以任一个结点出发访问链表的所以结点。

**双向链表(double linked list)：**在单链表的每个结点中，再设置一个指向其前驱结点的指针域。可以双向访问，是用空间换时间。

## 3.栈和队列

**栈(stack)：**是限定仅在表尾进行插入和删除操作的线性表。允许插入和删除的一端称为栈顶(top)，另一端称为栈底(bottom)，不含任何数据元素的栈称为空栈。栈又称后进先出(Last IN First Out)线性表，简称LIFO结构。
将栈看成垂直的，栈的插入操作，叫做进栈，也称压栈，入栈，栈的删除操作，叫做出栈，也叫弹栈。
对于栈的顺序存储结构来说，如果是两个相同数据结构的栈，则可以用数组的两端做栈底的方法来让两个栈实现共享数据，最大化利用数组的空间。

**队列(queue):**是限定在一端进行插入，在另一端进行删除操作的线性表。允许插入的一端称为队尾，允许删除的一端称为队首。队列是一种先入先出(First In First Out)的线性表，简称FIFO。类似于窗口排队。左边为队首，右边为队尾。
对于队列的顺序存储结构来说，为了避免数组的插入和删除时需要移动数据，于是就引入了循环队列，使得队头和队尾可以同时在数组中循环变。解决了移动数据的时间损耗，使得本来插入和删除是O(n)的时间复杂度变成了O(1)。

栈和队列都属于线性表，只不过是操作受到限制的线性表。

### 栈的实现

#### 栈的顺序存储结构的实现：

```c++
    结构定义：
    typedef struct
    {
        SElemType data[MAXSIZE];//开辟固定大小的数组，固定死了栈的大小
        int top;//栈顶元素的索引。栈实际上就是只能在一端进行插入删除的数组。
    }SqStack;
	进栈操作：
    Status Push(Sqstack *S,SElemType e)
    {
        if(S->top=MAXSIZE-1)  //栈已满
            return ERROR;
        S->top++;
        S->data[S->top]=e;//或连写为 S->data[++S->top]=e;
        return OK;
    }
	出栈操作：
    Status Pop(Sqstack *S,SElemType *e)
    {
        if(S->top==-1)   //栈为空
            return ERROR;
        *e=S->data[S->top];
        S->top--;//可简写为 *e=S->data[S->top--]；
        return OK;
    }
```

#### 栈的链式存储结构实现：

栈的链式存储结构简称为链栈。把栈顶放在单链表的头部，由于以及有了栈顶在头部了，单链表中常见的头结点也就失去了意义，故对于链栈不需要头结点。

```c++
	结构定义：
      typedef struct StackNode
    {
        SElemType data;
        struct StackNode *next;
    }StackNode,*LinkStackPtr;
	typedef strcut LinkStack
    {
        LinkStackPtr top;//栈顶指针
        int count; //当前栈的大小
    } LinkStack；
        
        进栈操作：
            Status Push(LinkStack *S,SElemType e)
    {
        LinkStackPtr s=(LinkStackPtr)malloc(sizeof(StackNode));
        s->data=e;
        s->netx=S->top;
        S->top=s;
        S->count++;
        return OK;
    }
        出栈操作：
            Status Pop(LinkStack *S,SElemType *e)
        {
			 LinkStackPtr temp;
            if(StackEmpty(*S))
                return ERROR;//为空栈
            *e=S->top->data;
            temp=S->top;
            S->top=S->top->next;
            free(p);
            S->count--;
            return OK;
        }
//进栈时需要考虑满的问题，出栈时需要考虑空的问题
```

### 队列的实现

#### 队列的顺序存储结构的实现：

利用固定数组容易造成假溢出，浪费存储空间。以使用循环队列解决该问题，所谓循环队列，就是头尾相连的队列，数组后面满了再从头开始。

```c++
	结构定义：
    typedef struct
    {
        Elemtype data[MAXSIZE];
        int front;//队首
        int rear;//队尾
    }SqQueue；
    循环队列的初始化：
        Status InitQueue(SqQueue *Q)
    {
        Q->fronr=0;
        Q->rear=0;//rear指向队列队尾元素的后一个位置。当数组满时，数组中还有一个空闲单元
        return OK;
    }
	循环队列求队列长度：
        int QueueLength(SqQueue Q)
    {
        return (Q.rear-Q.front+MAXSIZE)%MAXSIZE；
    }
	入队操作：
        Status EnQueue(SqQueue *Q, Elemtype e)
    {
        if((Q.rear+1)%MAXSIZE==Q.front)//队列已满
          return ERROR; 
        Q->data[Q->rear]=e;
        Q->rear=(Q->rear+1)%MAXSIZE;//若rear本是最后一位则转到数组头部
        return OK;
    }
	出队操作：
         Status DeQueue(SqQueue *Q, Elemtype *e)
    {
        if(Q.rear==Q.front)
            return ERROR;//队列为空
        *e=Q->data[Q->front];
        Q->front=(Q->front+1)%MAXSIZE;
        return OK;
    }
```

#### 队列的链式存储结构的实现：

```c++
	结构定义：
      typedef struct QNode
    {
        ElemType data;
        struct QNode *next;
    }QueueNode,*LinkQueuePtr;
	typedef strcut LinkQueue
    {
        LinkQueuePtr front,rear;//front指向头结点，rear指向队尾
    }LinkQueue;
	
	入队操作：
        Status EnQueue(LinkQueue *Q, ElemType e)
    {
        LinkQueuePtr s=(LinkStackPtr)malloc(sizeof(StackNode));
        if(!s)
            exit(OVERFLOW);//存储空间分配失败
        s->data=e;
        s->next=NULL;
        Q->rear->next=s;
        Q->rear=s;
        return OK;
    }
	出队操作：
          Status DeQueue(LinkQueue *Q, ElemType *e)
    {
        ListQueueptr temp;
        if(Q->rear==Q->front)
            return ERROR;//队列为空
        temp=Q->front->next;//默认队列包含头结点。
        *e=temp->data;
        Q->front->next=temp->next;
        if(temp==Q->rear)//如果队列中除了头结点只有一个结点，则使rear也指向头结点，否则不需要动rear。
            Q->rear=Q->front;
        free(temp);
        return OK;
    }
```

## 4.串

**串(string):**是由零个或多个字符组成的有限序列，又名字符串。

一般记为"a~1~a~2~a~3~....a~n~"，串中的字符数目n称为串的长度，零个字符的串称为空串(null string)。

所谓序列，是指串的相邻字符之间具有前驱和后继的关系。

串中任意个数的连续字符组成的子序列称为该串的子串，相应地，包含字串的串称为主串。

与线性表相比，线性表更关注单个元素的操作，比如查找一个元素，插入或删除一个元素。而串中更多的是查找子串位置，得到指定位置的子串，替换子串等操作。

串可以用顺序存储结构也可以用链式存储结构，但总的来说，顺序存储结构性能较好。

**ASCII编码和Unicode编码：**计算机中常用的字符是使用标准的ASCII编码，由7位二进制数表示一个字符，总共可以表示128个字符，后来又扩展到由8位二进制数表示一个字符，共可以表示256个字符。但这远远不够表示世界上的所以字符，因此有了Unicode编码，使用16位二进制数表示一个字符，总共可以表示2^16^个字符，约6.5万个，足够表示世界上所有的字符。为了和ASCII码兼容，Unicode的前256个字符与ASCII码相同。

子串的定位操作通常称为串的模式匹配，是串中最重要的操作之一。

#### 串的朴素模式匹配算法

```c++
int Index(string S, string T, int pos)
{
	int slen = S.size();
	int tlen = T.size();
	int i = pos;//从pos开始搜索
	int j = 0;
	while (i<slen&& j<tlen)   //不能写成i<slen-tlen+1
	{
		if (S[i] == T[j])
		{
			++i;
			++j;
		}
		else
		{
			i = i - j + 1;//注意这里，i返回到上次匹配首位的下一位。首元素放的是字符串的长度，则应写为i-j+2
            if (i == slen - tlen + 1)
				break;  
			j = 0;
		}
		if (j == tlen)
			return i - tlen;
	} 
	return 0;
}
```

#### KMP模式匹配算法

```c++
#include<iostream>
#include<string>
using namespace std;
void get_next(string T, int *next)

{
	int i = 0;
	int j = -1;
	next[0] = -1;
	while (i<T.size() - 1)
	{
		if (j == -1 || T[i] == T[j])
		{
			++i;
			++j;
			next[i] = j;
		}
		else
			j = next[j];
	}
}
void get_nextval(string T, int *nextval)//改进next

{
	int i = 0;
	int j = -1;
	nextval[0] = -1;
	while (i<T.size() - 1)
	{
		if (j == -1 || T[i] == T[j])
		{
			++i;
			++j;
			if (T[i] != T[j])
			{
				nextval[i] = j;
			}
			else
				nextval[i] = nextval[j];
		}
		else
			j = nextval[j];
	}
}
int Index_KMP(string S, string T, int pos)
{
	int slen = S.size();
	int tlen = T.size();
	int i = pos;//从pos开始搜索
	int j = 0;
	//int next[255];
	int nextval[255];
	//get_next(T, next);
	get_nextval(T, nextval);
	while (i<slen&& j<tlen)
	{
		if (j == -1 || S[i] == T[j])//不要写成S[i] == T[j]||j== -1 
		{
			++i;
			++j;
		}
		else
		{
			if (i == slen - tlen + 1)
				break;
			//j = next[i];
			j = nextval[j];
		}
		if (j == tlen)
			return i - tlen;
	}
	return 0;
}
int main()
{
	string s, t;
	cin >> s >> t;
	cout << s << endl;
	cout << t << endl;
	/*int nextval[255];
	get_nextval(t, nextval);
	for (int i = 0; i < 20; i++)
		cout << nextval[i] << " ";*/
	cout << Index_KMP(s, t, 0) << endl;
	return 0;
}
```



## 5.树

## 6.图

## 7.搜索算法

## 8.排序算法

​	